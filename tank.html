<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tank Game</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        margin: 0;
        background-color: #f0f0f0;
      }
      .game-container {
        text-align: center;
      }
      .grid {
        display: inline-grid;
        grid-template-columns: repeat(20, 30px);
        grid-gap: 1px;
        background-color: #ccc;
        padding: 1px;
        margin-bottom: 20px;
        position: relative;
      }
      .cell {
        width: 30px;
        height: 30px;
        background-color: #fff;
        display: flex;
        justify-content: center;
        align-items: center;
        position: relative;
      }
      .obstacle {
        background-color: #333;
      }
      .bullet {
        position: absolute;
        background-color: #ff0000;
        border-radius: 50%;
        width: 6px;
        height: 6px;
        transform: translate(-50%, -50%);
      }
      .tank-container {
        position: absolute;
        display: flex;
        flex-direction: column;
        align-items: center;
        transition: all 0.2s ease;
      }
      .tank {
        width: 25px;
        height: 25px;
        border-radius: 50%;
        display: flex;
        justify-content: center;
        align-items: center;
        color: white;
        font-size: 10px;
        position: relative;
        z-index: 2;
      }
      .tank::after {
        content: "";
        position: absolute;
        width: 15px;
        height: 3px;
        background-color: #000;
        top: 50%;
        left: 50%;
        transform-origin: left center;
        transition: transform 0.3s ease;
      }
      .golden-tank {
        background-color: gold;
        transition: all 0.1s ease;
      }
      .player-tank {
        background-color: #fff;
        background: linear-gradient(
          90deg,
          red 0%,
          red 25%,
          white 25%,
          white 50%,
          blue 50%,
          blue 100%
        );
        position: relative;
      }
      .tank-info {
        display: flex;
        flex-direction: column;
        align-items: center;
        margin-top: 2px;
      }
      .hp-bar {
        display: flex;
        justify-content: center;
      }
      .hp {
        width: 6px;
        height: 6px;
        background-color: red;
        border-radius: 50%;
        margin: 0 1px;
      }
      .countdown {
        font-size: 8px;
        color: #333;
        margin-top: 1px;
      }
      .shoot-range {
        background-color: rgba(255, 255, 0, 0.2);
      }
      #gameLog {
        max-width: 300px;
        margin: 0 auto;
        text-align: left;
        height: 150px;
        overflow-y: auto;
      }
      #gameLog h2 {
        margin-bottom: 10px;
      }
      #gameLog ul {
        padding-left: 20px;
      }
      .explosion {
        position: absolute;
        width: 30px;
        height: 30px;
        background-color: orange;
        border-radius: 50%;
        animation: explode 0.5s ease-out;
        z-index: 3;
      }
      @keyframes explode {
        0% {
          transform: scale(0);
          opacity: 1;
        }
        50% {
          transform: scale(1.5);
          opacity: 1;
        }
        100% {
          transform: scale(2);
          opacity: 0;
        }
      }

      /* Modal Style */
      .modal {
        display: none;
        position: fixed;
        z-index: 999;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        justify-content: center;
        align-items: center;
      }

      .modal-content {
        background-color: white;
        padding: 20px;
        border-radius: 10px;
        text-align: center;
      }

      #restartButton {
        margin-top: 20px;
        padding: 10px 20px;
        background-color: #333;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
      }

      #restartButton:hover {
        background-color: #555;
      }
    </style>
  </head>
  <body>
    <div class="game-container">
      <h1>Tank Game</h1>
      <div id="grid" class="grid"></div>
      <div id="gameLog">
        <h2>Game Log</h2>
        <ul id="logList"></ul>
      </div>
    </div>

    <!-- Modal Structure -->
    <div id="gameOverModal" class="modal">
      <div class="modal-content">
        <h2>Game Over!</h2>
        <p id="killCount"></p>
        <button id="restartButton">Restart</button>
      </div>
    </div>

    <script>
      const GRID_SIZE = 20;
      const OBSTACLE_SYMBOL = "#";
      const BULLET_SYMBOL = "*";
      const REGULAR_SHOOT_RANGE = 3;
      const PLAYER_SHOOT_RANGE = 3;
      const GOLDEN_SHOOT_RANGE = 6;
      const OBSTACLE_COUNT = 40;
      const MAX_TANK_COUNT = 50; // เพิ่มจำนวน tank เป็น 50 ตัว
      const TANK_COUNT = 50; // เริ่มต้นด้วย 50 tank
      const BULLET_SPEED = 200;
      const GOLDEN_BULLET_SPEED = 100;
      const CELL_SIZE = 31;
      const MAX_HP = 3;
      const GOLDEN_HP = 6;
      const PLAYER_HP = 3;
      const SHOOT_COOLDOWN = 3;
      const REGENERATION_THRESHOLD = 0.1; // Tank ตาย 10% ให้สุ่มเกิดใหม่

      let grid = Array(GRID_SIZE)
        .fill()
        .map(() => Array(GRID_SIZE).fill("."));
      let tanks = [];
      let bullets = [];
      let gameInterval;
      let bulletInterval;
      let playerKills = 0;
      let totalTankDeaths = 0;

      function generateTankColor(id) {
        const hue = (id * 137.5) % 360;
        return `hsl(${hue}, 70%, 50%)`;
      }

      function spawnRandomTank(fullyHealed = false) {
        let x, y;
        do {
          x = Math.floor(Math.random() * GRID_SIZE);
          y = Math.floor(Math.random() * GRID_SIZE);
        } while (grid[y][x] !== ".");

        const direction = ["up", "right", "down", "left"][
          Math.floor(Math.random() * 4)
        ];

        // ถ้า fullyHealed = true ให้ tank เกิดใหม่มี HP 3, ถ้าไม่ใช่ให้สุ่ม HP 1 - 3
        const hp = fullyHealed ? MAX_HP : Math.floor(Math.random() * 3) + 1;

        const tank = {
          id: tanks.length + 1,
          x,
          y,
          direction,
          symbol: `T${tanks.length + 1}`,
          hp,
          shootCooldown: 0,
          shootRange: REGULAR_SHOOT_RANGE,
          bulletSpeed: BULLET_SPEED,
        };
        tanks.push(tank);
        grid[y][x] = tank.symbol;

        const style = document.createElement("style");
        style.textContent = `.tank${
          tank.id
        } { background-color: ${generateTankColor(tank.id)}; }`;
        document.head.appendChild(style);

        addToGameLog(`New tank T${tank.id} spawned with ${hp} HP!`);
      }

      function initializeTanks() {
        for (let i = 0; i < TANK_COUNT; i++) {
          spawnRandomTank();
        }

        let goldenX, goldenY;
        do {
          goldenX = Math.floor(Math.random() * GRID_SIZE);
          goldenY = Math.floor(Math.random() * GRID_SIZE);
        } while (grid[goldenY][goldenX] !== ".");

        const goldenTank = {
          id: "Golden",
          x: goldenX,
          y: goldenY,
          direction: "up",
          symbol: "G",
          hp: GOLDEN_HP,
          shootCooldown: 0,
          shootRange: GOLDEN_SHOOT_RANGE,
          bulletSpeed: GOLDEN_BULLET_SPEED,
          isGolden: true,
        };
        tanks.push(goldenTank);
        grid[goldenY][goldenX] = goldenTank.symbol;

        let playerX, playerY;
        do {
          playerX = Math.floor(Math.random() * GRID_SIZE);
          playerY = Math.floor(Math.random() * GRID_SIZE);
        } while (grid[playerY][playerX] !== ".");

        const playerTank = {
          id: "Player",
          x: playerX,
          y: playerY,
          direction: "up",
          symbol: "P",
          hp: PLAYER_HP,
          shootCooldown: 0,
          shootRange: PLAYER_SHOOT_RANGE,
          bulletSpeed: BULLET_SPEED,
          isPlayer: true,
        };
        tanks.push(playerTank);
        grid[playerY][playerX] = playerTank.symbol;
      }

      function placeObstacles() {
        for (let i = 0; i < OBSTACLE_COUNT; i++) {
          let x, y;
          do {
            x = Math.floor(Math.random() * GRID_SIZE);
            y = Math.floor(Math.random() * GRID_SIZE);
          } while (grid[y][x] !== ".");
          grid[y][x] = OBSTACLE_SYMBOL;
        }
      }

      function renderGrid() {
        const gridElement = document.getElementById("grid");
        gridElement.innerHTML = "";

        grid.forEach((row, y) => {
          row.forEach((cell, x) => {
            const cellElement = document.createElement("div");
            cellElement.className = "cell";
            cellElement.dataset.x = x;
            cellElement.dataset.y = y;
            if (cell === OBSTACLE_SYMBOL) {
              cellElement.classList.add("obstacle");
            }
            gridElement.appendChild(cellElement);
          });
        });

        tanks.forEach((tank) => {
          const tankContainer = document.createElement("div");
          tankContainer.className = "tank-container";
          tankContainer.style.left = `${tank.x * CELL_SIZE}px`;
          tankContainer.style.top = `${tank.y * CELL_SIZE}px`;

          const tankElement = document.createElement("div");
          tankElement.className = `tank tank${tank.id} ${
            tank.isGolden ? "golden-tank" : tank.isPlayer ? "player-tank" : ""
          }`;
          tankElement.textContent = tank.symbol;
          const rotation = directionToDegrees(tank.direction);
          tankElement.style.transform = `rotate(${rotation}deg)`;

          const tankInfo = document.createElement("div");
          tankInfo.className = "tank-info";

          const hpBar = document.createElement("div");
          hpBar.className = "hp-bar";
          const totalHp = tank.isGolden
            ? GOLDEN_HP
            : tank.isPlayer
            ? PLAYER_HP
            : MAX_HP;
          for (let i = 0; i < totalHp; i++) {
            const hp = document.createElement("div");
            hp.className = "hp";
            hp.style.opacity = i < tank.hp ? 1 : 0.3;
            hpBar.appendChild(hp);
          }

          const countdown = document.createElement("div");
          countdown.className = "countdown";
          countdown.textContent =
            tank.shootCooldown > 0 ? tank.shootCooldown : "";

          tankInfo.appendChild(hpBar);
          tankInfo.appendChild(countdown);

          tankContainer.appendChild(tankElement);
          tankContainer.appendChild(tankInfo);
          gridElement.appendChild(tankContainer);

          const [dx, dy] = getDirectionVector(tank.direction);
          for (let i = 1; i <= tank.shootRange; i++) {
            const rangeX = tank.x + dx * i;
            const rangeY = tank.y + dy * i;
            if (
              rangeX >= 0 &&
              rangeX < GRID_SIZE &&
              rangeY >= 0 &&
              rangeY < GRID_SIZE
            ) {
              if (grid[rangeY][rangeX] === OBSTACLE_SYMBOL) {
                break;
              }
              const rangeCell = document.querySelector(
                `.cell[data-x="${rangeX}"][data-y="${rangeY}"]`
              );
              if (rangeCell) {
                rangeCell.classList.add("shoot-range");
              }
            } else {
              break;
            }
          }
        });

        renderBullets();
      }

      function renderBullets() {
        const gridElement = document.getElementById("grid");
        gridElement.querySelectorAll(".bullet").forEach((b) => b.remove());
        bullets.forEach((bullet) => {
          if (
            bullet.x >= 0 &&
            bullet.x < GRID_SIZE &&
            bullet.y >= 0 &&
            bullet.y < GRID_SIZE
          ) {
            const bulletElement = document.createElement("div");
            bulletElement.className = "bullet";
            bulletElement.style.left = `${
              bullet.x * CELL_SIZE + CELL_SIZE / 2
            }px`;
            bulletElement.style.top = `${
              bullet.y * CELL_SIZE + CELL_SIZE / 2
            }px`;
            gridElement.appendChild(bulletElement);
          }
        });
      }

      function getDirectionVector(direction) {
        const directionVectors = {
          up: [0, -1],
          down: [0, 1],
          left: [-1, 0],
          right: [1, 0],
          "up-left": [-1, -1],
          "up-right": [1, -1],
          "down-left": [-1, 1],
          "down-right": [1, 1],
        };
        return directionVectors[direction] || [0, 0];
      }

      function directionToDegrees(direction) {
        const directionMap = {
          up: 270,
          down: 90,
          left: 180,
          right: 0,
          "up-left": 225,
          "up-right": 315,
          "down-left": 135,
          "down-right": 45,
        };
        return directionMap[direction] || 0;
      }

      function moveTank(tank) {
        const directions = [
          "up",
          "up-right",
          "right",
          "down-right",
          "down",
          "down-left",
          "left",
          "up-left",
        ];
        const newTank = { ...tank };

        const newDirection =
          directions[Math.floor(Math.random() * directions.length)];
        newTank.direction = newDirection;

        const [dx, dy] = getDirectionVector(newDirection);
        const newX = tank.x + dx;
        const newY = tank.y + dy;

        if (
          newX >= 0 &&
          newX < GRID_SIZE &&
          newY >= 0 &&
          newY < GRID_SIZE &&
          grid[newY][newX] === "."
        ) {
          grid[tank.y][tank.x] = ".";
          newTank.x = newX;
          newTank.y = newY;
          grid[newY][newX] = tank.symbol;
          addToGameLog(`Tank ${tank.id} moved ${newDirection}`);
        } else {
          addToGameLog(
            `Tank ${tank.id} rotated to ${newDirection} but couldn't move`
          );
        }

        return newTank;
      }

      function shoot(tank) {
        if (tank.shootCooldown > 0) return;

        const [dx, dy] = getDirectionVector(tank.direction);
        let x = tank.x + dx;
        let y = tank.y + dy;

        if (x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE) {
          bullets.push({
            x: tank.x,
            y: tank.y,
            dx,
            dy,
            range: tank.shootRange,
            shooterId: tank.id,
          });
          addToGameLog(`Tank ${tank.id} fired a shot!`);
          tank.shootCooldown = SHOOT_COOLDOWN;
        } else {
          addToGameLog(`Tank ${tank.id} tried to shoot outside the grid!`);
        }
      }

      function updateBullets() {
        bullets = bullets.filter((bullet) => {
          let newX = bullet.x;
          let newY = bullet.y;
          const steps = Math.max(Math.abs(bullet.dx), Math.abs(bullet.dy));
          const stepX = bullet.dx / steps;
          const stepY = bullet.dy / steps;

          for (let i = 0; i < steps; i++) {
            newX += stepX;
            newY += stepY;

            if (
              newX < 0 ||
              newX >= GRID_SIZE ||
              newY < 0 ||
              newY >= GRID_SIZE
            ) {
              addToGameLog(`A bullet went out of bounds!`);
              return false;
            }

            const gridX = Math.floor(newX);
            const gridY = Math.floor(newY);

            if (grid[gridY][gridX] === OBSTACLE_SYMBOL) {
              addToGameLog(`A bullet hit an obstacle!`);
              createExplosion(gridX, gridY);
              return false;
            }

            const hitTank = tanks.find(
              (t) => t.x === gridX && t.y === gridY && t.id !== bullet.shooterId
            );
            if (hitTank) {
              hitTank.hp--;
              addToGameLog(`Tank ${hitTank.id} was hit! HP: ${hitTank.hp}`);
              createExplosion(gridX, gridY);
              if (hitTank.hp <= 0) {
                addToGameLog(`Tank ${hitTank.id} was destroyed!`);
                totalTankDeaths++; // นับจำนวน tank ที่ตาย
                if (bullet.shooterId === "Player") {
                  playerKills++;
                  addToGameLog(`Player Tank destroyed tank ${hitTank.id}!`);
                }
                grid[hitTank.y][hitTank.x] = ".";
                tanks = tanks.filter((t) => t.id !== hitTank.id);
              }
              return false;
            }
          }

          bullet.x = newX;
          bullet.y = newY;
          bullet.range--;

          return bullet.range > 0;
        });

        renderBullets();
      }

      function createExplosion(x, y) {
        const explosion = document.createElement("div");
        explosion.className = "explosion";
        explosion.style.left = `${x * CELL_SIZE}px`;
        explosion.style.top = `${y * CELL_SIZE}px`;
        document.querySelector(".grid").appendChild(explosion);
        setTimeout(() => explosion.remove(), 500);
      }

      function addToGameLog(message) {
        const logList = document.getElementById("logList");
        const logItem = document.createElement("li");
        logItem.textContent = message;
        logList.insertBefore(logItem, logList.firstChild);
        if (logList.children.length > 20) {
          logList.removeChild(logList.lastChild);
        }
      }

      function updateTanks() {
        tanks.forEach((tank) => {
          if (tank.shootCooldown > 0) {
            tank.shootCooldown--;
          }
        });
      }

      function showGameOverModal(kills) {
        const modal = document.getElementById("gameOverModal");
        const killCountText = document.getElementById("killCount");
        killCountText.textContent = `Player Tank killed ${kills} tanks!`;
        modal.style.display = "flex";
      }

      document
        .getElementById("restartButton")
        .addEventListener("click", function () {
          window.location.reload();
        });

      function checkGameOver() {
        const playerTank = tanks.find((tank) => tank.id === "Player");
        if (!playerTank) {
          clearInterval(gameInterval);
          clearInterval(bulletInterval);
          addToGameLog(`Game Over! Player Tank was destroyed!`);
          showGameOverModal(playerKills);
          return true;
        }
        return false;
      }

      function gameLoop() {
        updateTanks();
        tanks = tanks.map((tank) => {
          const newTank = moveTank(tank);
          if (Math.random() < 0.3) {
            shoot(newTank);
          }
          return newTank;
        });

        // ตรวจสอบว่าจำนวน tank ที่ตายถึง 10% ของจำนวนเริ่มต้นหรือไม่
        if (totalTankDeaths >= TANK_COUNT * REGENERATION_THRESHOLD) {
          totalTankDeaths = 0; // รีเซ็ตการนับจำนวน tank ที่ตาย
          const tanksToSpawn = Math.min(10, MAX_TANK_COUNT - tanks.length);
          for (let i = 0; i < tanksToSpawn; i++) {
            spawnRandomTank(true); // tank ใหม่จะมี HP เต็ม 3 ดวง
          }
        }

        renderGrid();

        if (checkGameOver()) {
          renderGrid();
        }
      }

      function initGame() {
        placeObstacles();
        initializeTanks();
        renderGrid();
        gameInterval = setInterval(gameLoop, 1000);
        bulletInterval = setInterval(updateBullets, BULLET_SPEED);
      }

      initGame();
    </script>
  </body>
</html>
